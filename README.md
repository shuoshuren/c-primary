c++入门

typeid()操作符：获取一个表达式的类型，返回结果是const type_info&类型
使用方法：typeid(类型或变量或表达式).name() 返回类型名字字符串

c++新增类型：
wchar_t:用在国际化程序的实现中，unicode编码的宽字符一般以wchar_t类型存储
bool：1个字节，用于条件判断，false为假，true为真
longlong：long占4个字节，longlong占8个字节
auto：c++11引入的auto类型，能让编译器自动分析表达式的类型

__asm：用于调用内联汇编程序，后面可以跟一个程序指令，一组括在大括号中指令或者一堆空大括号

&:引用，相当于起了一个别名
引用规则：1.引用被创建的同时必须被初始化
2.无NULL引用，引用必须与合法的存储单元关联
3.一旦引用被初始化，就不能改变引用的关系

c++头文件
C++头文件不带.h,当c++需要包含c的头文件的时候，前面加c字符串，去掉.h
.h头文件中，只能放变量或者函数的声明，不能放定义
例外：
1.头文件可以定义const对象，全局的const对象默认是没有extern的声明，只在当前文件占有效，static对象定义也可以放进头文件
2.头文件中可以定义内联函数（inline),inline函数是需要编译器在遇到它的地方根据定义内联展开，不会链接
3.头文件中可以定义类（class),此外，把函数成员的实现写入类的定义，此刻成员函数被编译器视为内联，如果成员函数的定义写在类定义的头文件中，没有写入类定义中，这是非法的，此刻成员函数就不是内联的

namespace:名字空间就是解决名称冲突的问题
命名空间的别名：namespace 别名=命名空间名
using namespace 命名空间名：所指定的命名空间的所有成员都直接可用，无需要加前缀修饰。
匿名命名空间：不仅可以避免名称冲突，还可以使代码保持局部性，保护代码不被他人非法使用
匿名命名空间：namespace{
	声明序列可选
}

new,delete运算符：是c++用于分配，释放堆内存的两个运算符，功能对应于C语言的malloc和 free两个函数
new的语法：
类型* p = new 类型；
e.g: int * p = new int;
new的同时初始化：
类型 * p = new 类型(初始值);
e.g: int * p = new int(123)
new 一个数组：
类型 * p = new 类型[N];
new一个数组显式初始化：
类型 * p = new 类型[N]{初始值1，初始值2...};

delete用法：
delet p;
delete释放数组内存：
delete []p;

输出输出：
cout语句：cout<<表达式1<<表达式2<<endl;

inline:使用关键字inline放在函数定义的前面可将函数指定为内联函数，内联函数通常将它在程序的每一个调用点上内联展开
inline函数定义在源文件中只能出现一次，可以在程序中定义多次，但是定义必须完全相同。